该项目是基于zookeeper分布式器,protobuf库和muduo库实现的分布式通信框架。一个工程可以在多个服务器上实现。在该项目中，主要使用zookeeper的注册中心服务来保存各个服务器的ip和port，客户端通过该注册中心来访问各个服务的函数。利用zookeeper自身API的心跳机制对各个服务进行维护（心跳主要通过网络I/O线程实现，底层使用的时pool复用技术）。protobuf是用于对数据的序列化与反序列化，调用方与被调用方需要使用一种消息类型，RPC接收和发送需要一个信息类型。muduo主要是用来实现该RPC框架的高并发，对于muduo库连接操作以及消息操作函数进行了重写。
主要流程：
    被调用方（没有客户端访问）：首先构造本地服务，继承rpc的服务，并对基类虚函数进行重写。   首先对框架初始化，主要是将自己服务器ip和port放在具有单列模式的哈希map中，然后将服务和函数放在rpc的服务函数map表中，最后创建muduo库并将rpc节点的服务函数的ip和port信息注册在zookeeper上，对于zookeeper注册，服务创建为永久性节点，函数被创建为临时性节点，主要是为了防止该服务器函数的增删。由于zookeeper的连接是异步的，因此在创建zookeeper时，需要创建全局回调wather函数以及为句柄设置一个初始化为0的信号量，通过wather线程判断状态来判断是否创建成功，并通过信号量增加来提醒主线程的继续运行。创建节点的细节，要一层一层的创建才行。
    被调用方（有客户端访问）：当有客户端进行数据传输时，首先按照rpc的protobuf信息类型，对信息进行反序列化，通过反序列化得到的服务以及函数在rpc服务函数map中找到，绑定响应回调函数并调用本地服务器的函数，最后调用响应回调函数为调用者提供相应的信息。
    调用方：需要stub创建代理对象来访问服务函数，当通过stub代理对象访问服务函数时，都会做相同的操作（所有参数类型都需要使用基类），就是通过rpc protobuf消息类型来找到所找的服务名，函数名以及参数大小并将这些信息序列化，然后连接zookeeper注册中心获取相应函数所在服务器的ip，port并发送消息。等待响应消息，接收到响应消息后关闭连接。
    
异步日志功能，封装了一个模板日志消息队列，通过条件变量以及互斥锁来控制日志线程对于消息队列的读写。当往消息队列中存数据时，通过智能指针对队列加锁和释放锁。当从队列中取数据并且队列为空时，通过信号量进行阻塞，防止程序出错，直到队列有数据时，写线程运行向文件中写数据。
